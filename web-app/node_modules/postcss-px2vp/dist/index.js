"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const pixel_unit_regexp_1 = __importDefault(require("./pixel-unit-regexp"));
const prop_list_matcher_1 = require("./prop-list-matcher");
const getDefault = () => ({
    unitToConvert: 'px',
    viewportWidth: 320,
    viewportHeight: 568,
    unitPrecision: 5,
    viewportUnit: 'vw',
    fontViewportUnit: 'vw',
    selectorBlackList: [],
    propList: ['*'],
    minPixelValue: 1,
    mediaQuery: false,
    replace: true,
    landscape: false,
    landscapeUnit: 'vw',
    exclude: [],
    landscapeWidth: 568
});
const postcssPlugin = 'postcss-px2vp';
const IGNORE_NEXT_COMMENT = 'px-to-viewport-ignore-next';
const IGNORE_PREV_COMMENT = 'px-to-viewport-ignore';
const isExclude = (exclude, file) => {
    if (!file)
        return false;
    if (Array.isArray(exclude))
        return exclude.some(reg => reg.test(file));
    return exclude.test(file);
};
function getOption(option, rule) {
    return typeof option === 'function' ? option(rule) : option;
}
function toFixed(number, precision) {
    var multiplier = Math.pow(10, precision + 1), wholeNumber = Math.floor(number * multiplier);
    return (Math.round(wholeNumber / 10) * 10) / multiplier;
}
function createPxReplace(opts, viewportUnit, viewportSize) {
    return function (m, $1) {
        if (!$1)
            return m;
        var pixels = parseFloat($1);
        if (pixels <= opts.minPixelValue)
            return m;
        var parsedVal = toFixed((pixels / viewportSize) * 100, opts.unitPrecision);
        return parsedVal === 0 ? '0' : `${parsedVal}${viewportUnit}`;
    };
}
function validateParams(params, mediaQuery) {
    return !params || (params && mediaQuery);
}
function getUnit(prop, opts) {
    return !prop.includes('font') ? opts.viewportUnit : opts.fontViewportUnit;
}
function declarationExists(decls, prop, value) {
    if (!decls)
        return false;
    return decls.some(function (decl) {
        return decl.prop === prop && decl.value === value;
    });
}
function optionCreator({ options, rule, defaultOptions }) {
    if (!options)
        return defaultOptions;
    return Object.assign(Object.assign({}, defaultOptions), Object.entries(options).reduce((prev, [key, value]) => {
        prev[key] = getOption(value, rule);
        return prev;
    }, {}));
}
const blacklistedSelector = (blacklist, selector) => blacklist.some(rule => {
    if (typeof rule === 'string')
        return selector.includes(rule);
    return rule.test(selector);
});
const px2vp = options => {
    const landscapeRules = [];
    const defaultOptions = getDefault();
    return {
        postcssPlugin,
        Once(root, { atRule, result }) {
            root.walkRules(rule => {
                var _a, _b;
                const file = (_a = rule.source) === null || _a === void 0 ? void 0 : _a.input.file;
                const { exclude, selectorBlackList, propList, landscape, unitToConvert, minPixelValue, unitPrecision, landscapeUnit, landscapeWidth, fontViewportUnit, viewportUnit, mediaQuery, viewportWidth, replace } = optionCreator({ options, rule, defaultOptions });
                // init options
                const pxRegex = pixel_unit_regexp_1.default(unitToConvert);
                const satisfyPropList = prop_list_matcher_1.createPropListMatcher(propList);
                const params = (_b = rule.parent) === null || _b === void 0 ? void 0 : _b.params;
                if (isExclude(exclude, file) ||
                    blacklistedSelector(selectorBlackList, rule.selector))
                    return;
                if (landscape && !params) {
                    const landscapeRule = rule.clone().removeAll();
                    rule.walkDecls(decl => {
                        const { value, prop } = decl;
                        if (!value.includes(unitToConvert) || !satisfyPropList(prop))
                            return;
                        landscapeRule.append(decl.clone({
                            value: value.replace(pxRegex, createPxReplace({ minPixelValue, unitPrecision }, landscapeUnit, landscapeWidth))
                        }));
                        if (landscapeRule.nodes.length > 0) {
                            landscapeRules.push(landscapeRule);
                        }
                    });
                }
                if (!validateParams(params, mediaQuery))
                    return;
                rule.walkDecls((decl, i) => {
                    var _a, _b;
                    let { value, prop } = decl;
                    if (!value.includes(unitToConvert) || !satisfyPropList(prop))
                        return;
                    const prev = decl.prev();
                    if ((prev === null || prev === void 0 ? void 0 : prev.type) === 'comment' && prev.text === IGNORE_NEXT_COMMENT) {
                        prev.remove();
                        return;
                    }
                    const next = decl.next();
                    if ((next === null || next === void 0 ? void 0 : next.type) === 'comment' && next.text === IGNORE_PREV_COMMENT) {
                        if (/\n/.test((_a = next.raws.before) !== null && _a !== void 0 ? _a : '')) {
                            result.warn('Unexpected comment /* ' +
                                IGNORE_PREV_COMMENT +
                                ' */ must be after declaration at same line.', { node: next });
                        }
                        else {
                            // remove comment
                            next.remove();
                            return;
                        }
                    }
                    const [unit, size] = landscape && (params === null || params === void 0 ? void 0 : params.includes('landscape'))
                        ? [landscapeUnit, landscapeWidth]
                        : [
                            getUnit(prop, { viewportUnit, fontViewportUnit }),
                            viewportWidth
                        ];
                    value = value.replace(pxRegex, createPxReplace({ minPixelValue, unitPrecision }, unit, size));
                    if (declarationExists(decl.parent, prop, value))
                        return;
                    if (replace)
                        decl.value = value;
                    else
                        (_b = decl.parent) === null || _b === void 0 ? void 0 : _b.insertAfter(i, decl.clone({ value: value }));
                });
            });
            if (landscapeRules.length) {
                const landscapeRoot = atRule({
                    params: '(orientation: landscape)',
                    name: 'media'
                });
                landscapeRules.forEach(rule => {
                    landscapeRoot.append(rule);
                });
                root.append(landscapeRoot);
            }
        }
    };
};
px2vp.postcss = true;
module.exports = px2vp;
//# sourceMappingURL=index.js.map